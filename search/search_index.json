{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Run away 2 O que \u00e9 o nosso projeto? \u00c9 um jogo, onde jogador deve escolher os melhores tesouros para obter a maior quantidade de moedas, ent\u00e3o ele deve adivinhar o caminho mais curto para fora da floresta para n\u00e3o perder as moedas. Membros: Nome Github Matr\u00edcula Kathlyn Lara Murussi @klmurussi 18/0042378 J\u00falio C\u00e9sar Schneider Martins @jschneiderm98 16/0032903 Screenshots: Sele\u00e7\u00e3o de b\u00e1us B\u00e1us selecionados Parte da fuga da floresta V\u00eddeo da dupla","title":"In\u00edcio"},{"location":"#run-away-2","text":"","title":"Run away 2"},{"location":"#o-que-e-o-nosso-projeto","text":"\u00c9 um jogo, onde jogador deve escolher os melhores tesouros para obter a maior quantidade de moedas, ent\u00e3o ele deve adivinhar o caminho mais curto para fora da floresta para n\u00e3o perder as moedas.","title":"O que \u00e9 o nosso projeto?"},{"location":"#membros","text":"Nome Github Matr\u00edcula Kathlyn Lara Murussi @klmurussi 18/0042378 J\u00falio C\u00e9sar Schneider Martins @jschneiderm98 16/0032903","title":"Membros:"},{"location":"#screenshots","text":"","title":"Screenshots:"},{"location":"#selecao-de-baus","text":"","title":"Sele\u00e7\u00e3o de b\u00e1us"},{"location":"#baus-selecionados","text":"","title":"B\u00e1us selecionados"},{"location":"#parte-da-fuga-da-floresta","text":"","title":"Parte da fuga da floresta"},{"location":"#video-da-dupla","text":"","title":"V\u00eddeo da dupla"},{"location":"algoritmos/","text":"Algoritmos utilizados Grafos Foi utilizado grafos como os n\u00f3s do labirinto da parte de fuga. As arestas do grafo possuiam peso. class Graph : def __init__ ( self ): self . graph = {} self . weights = {} self . qtd = 0 self . treasures = [] self . total = 0 class Node ( pygame . sprite . Sprite ): def __init__ ( self , num , x , y ): super () . __init__ () self . image = Images . node self . rect = self . image . get_rect () self . rect . x = x self . rect . y = y self . num = num Sprites . node_list . add ( self ) Sprites . all_sprites_list . add ( self ) def add_node ( self , num , x , y ): empty_node = Node . Node ( num , x , y ) self . graph [ empty_node ] = [] return empty_node def add_edge ( self , src , dest , weight ): if ( dest in self . graph [ src ]): return self . graph [ src ] . append ( dest ) self . graph [ dest ] . append ( src ) self . weights [( src . num , dest . num )] = weight self . weights [( dest . num , src . num )] = weight edge = Connection . Connection ( ( src . rect . x + 16 , src . rect . y + 16 ), ( dest . rect . x + 16 , dest . rect . y + 16 ), weight ) Algoritmos ambiciosos e Grafos (Dijkstra) Al\u00e9m disso, foi utilizado o algoritmo de Dijkstra para o menor caminho que al\u00e9m de um algorimo para grafos \u00e9 um algoritmo ambicioso. def dijkstra_end ( self , start , end ): distance = { node : inf for node in self . graph } visited = { node : False for node in self . graph } pq = PriorityQueue () distance [ start ] = 0 pq . add (( 0 , start )) for next_node in self . graph [ start ]: initial_weight = self . weights [( start . num , next_node . num )] pq . add (( initial_weight , next_node )) while not pq . isEmpty (): currentVert = pq . delMin () visited [ currentVert ] = True if ( visited [ end ]): break for nextVert in self . graph [ currentVert ]: newDist = distance [ currentVert ] \\ + self . weights [( currentVert . num , nextVert . num )] if newDist < distance [ nextVert ]: distance [ nextVert ] = newDist pq . decreaseKey ( nextVert , newDist ) pq . add (( newDist , nextVert )) return distance [ end ] Programa\u00e7\u00e3o Din\u00e2mica (Knapsack) Por \u00faltimo foi utilizado o algoritmo Knapsack de programa\u00e7\u00e3o din\u00e2mica. def k ( capacidade , node , qtd ): #capacidade = int(capatidade) K = [[ 0 for x in range ( capacidade + 1 )] for x in range ( qtd + 1 )] for nodeAtual in range ( 1 , qtd + 1 ): for pesoAtual in range ( 1 , capacidade + 1 ): if pesoAtual >= node [ nodeAtual - 1 ] . peso : K [ nodeAtual ][ pesoAtual ] = max ( node [ nodeAtual - 1 ] . premio + K [ nodeAtual - 1 ][ pesoAtual - node [ nodeAtual - 1 ] . peso ], K [ nodeAtual - 1 ][ pesoAtual ]) else : K [ nodeAtual ][ pesoAtual ] = K [ nodeAtual - 1 ][ pesoAtual ] res = findSolution ( node , K , qtd , capacidade ) return ( res ) def findSolution ( treasures , K , qtdObj , capacidade ): res = K [ qtdObj ][ capacidade ] #print(res) cap = capacidade resObjs = Graph . Graph () for i in range ( qtdObj , 0 , - 1 ): if res <= 0 : break if res == K [ i - 1 ][ cap ]: continue else : resObjs . add ( treasures [ i - 1 ]) res = res - treasures [ i - 1 ] . premio cap = cap - treasures [ i - 1 ] . peso return ( resObjs )","title":"Algoritmos utilizados"},{"location":"algoritmos/#algoritmos-utilizados","text":"","title":"Algoritmos utilizados"},{"location":"algoritmos/#grafos","text":"Foi utilizado grafos como os n\u00f3s do labirinto da parte de fuga. As arestas do grafo possuiam peso. class Graph : def __init__ ( self ): self . graph = {} self . weights = {} self . qtd = 0 self . treasures = [] self . total = 0 class Node ( pygame . sprite . Sprite ): def __init__ ( self , num , x , y ): super () . __init__ () self . image = Images . node self . rect = self . image . get_rect () self . rect . x = x self . rect . y = y self . num = num Sprites . node_list . add ( self ) Sprites . all_sprites_list . add ( self ) def add_node ( self , num , x , y ): empty_node = Node . Node ( num , x , y ) self . graph [ empty_node ] = [] return empty_node def add_edge ( self , src , dest , weight ): if ( dest in self . graph [ src ]): return self . graph [ src ] . append ( dest ) self . graph [ dest ] . append ( src ) self . weights [( src . num , dest . num )] = weight self . weights [( dest . num , src . num )] = weight edge = Connection . Connection ( ( src . rect . x + 16 , src . rect . y + 16 ), ( dest . rect . x + 16 , dest . rect . y + 16 ), weight )","title":"Grafos"},{"location":"algoritmos/#algoritmos-ambiciosos-e-grafos-dijkstra","text":"Al\u00e9m disso, foi utilizado o algoritmo de Dijkstra para o menor caminho que al\u00e9m de um algorimo para grafos \u00e9 um algoritmo ambicioso. def dijkstra_end ( self , start , end ): distance = { node : inf for node in self . graph } visited = { node : False for node in self . graph } pq = PriorityQueue () distance [ start ] = 0 pq . add (( 0 , start )) for next_node in self . graph [ start ]: initial_weight = self . weights [( start . num , next_node . num )] pq . add (( initial_weight , next_node )) while not pq . isEmpty (): currentVert = pq . delMin () visited [ currentVert ] = True if ( visited [ end ]): break for nextVert in self . graph [ currentVert ]: newDist = distance [ currentVert ] \\ + self . weights [( currentVert . num , nextVert . num )] if newDist < distance [ nextVert ]: distance [ nextVert ] = newDist pq . decreaseKey ( nextVert , newDist ) pq . add (( newDist , nextVert )) return distance [ end ]","title":"Algoritmos ambiciosos e Grafos (Dijkstra)"},{"location":"algoritmos/#programacao-dinamica-knapsack","text":"Por \u00faltimo foi utilizado o algoritmo Knapsack de programa\u00e7\u00e3o din\u00e2mica. def k ( capacidade , node , qtd ): #capacidade = int(capatidade) K = [[ 0 for x in range ( capacidade + 1 )] for x in range ( qtd + 1 )] for nodeAtual in range ( 1 , qtd + 1 ): for pesoAtual in range ( 1 , capacidade + 1 ): if pesoAtual >= node [ nodeAtual - 1 ] . peso : K [ nodeAtual ][ pesoAtual ] = max ( node [ nodeAtual - 1 ] . premio + K [ nodeAtual - 1 ][ pesoAtual - node [ nodeAtual - 1 ] . peso ], K [ nodeAtual - 1 ][ pesoAtual ]) else : K [ nodeAtual ][ pesoAtual ] = K [ nodeAtual - 1 ][ pesoAtual ] res = findSolution ( node , K , qtd , capacidade ) return ( res ) def findSolution ( treasures , K , qtdObj , capacidade ): res = K [ qtdObj ][ capacidade ] #print(res) cap = capacidade resObjs = Graph . Graph () for i in range ( qtdObj , 0 , - 1 ): if res <= 0 : break if res == K [ i - 1 ][ cap ]: continue else : resObjs . add ( treasures [ i - 1 ]) res = res - treasures [ i - 1 ] . premio cap = cap - treasures [ i - 1 ] . peso return ( resObjs )","title":"Programa\u00e7\u00e3o Din\u00e2mica (Knapsack)"},{"location":"ambiente/","text":"Instala\u00e7\u00e3o Linguagem : Python Framework : Pygame O projeto foi criado em um ambiente de desenvolvimento linux utilizando a IDE VSCode Inicialmente, caso n\u00e3o haja uma vers\u00e3o instalada, instale o python3 Tamb\u00e9m \u00e9 necesspario utilizar o gerenciador de pacotes do python3 o pip3 Ap\u00f3s obter o pip3, basta utilizar o pip3 pela linha de comando para obter a biblioteca pygame pip3 install pygame pip3 install pythonds Caso esteja utilizando o VSCode, \u00e9 necess\u00e1rio instalar as extens\u00f5es Pylance e Python Uso Para uso do projeto basta rodar o projeto a partir a partir da pasta do projeto python3 sources/main.py","title":"Ambiete de desenvolvimento"},{"location":"ambiente/#instalacao","text":"Linguagem : Python Framework : Pygame O projeto foi criado em um ambiente de desenvolvimento linux utilizando a IDE VSCode Inicialmente, caso n\u00e3o haja uma vers\u00e3o instalada, instale o python3 Tamb\u00e9m \u00e9 necesspario utilizar o gerenciador de pacotes do python3 o pip3 Ap\u00f3s obter o pip3, basta utilizar o pip3 pela linha de comando para obter a biblioteca pygame pip3 install pygame pip3 install pythonds Caso esteja utilizando o VSCode, \u00e9 necess\u00e1rio instalar as extens\u00f5es Pylance e Python","title":"Instala\u00e7\u00e3o"},{"location":"ambiente/#uso","text":"Para uso do projeto basta rodar o projeto a partir a partir da pasta do projeto python3 sources/main.py","title":"Uso"}]}